# The continual learning in Simulation-Driven Differentiable Active Learning framework for efficient data generation

In the initial commit to this Continual-SDDAL repository, an original SDDAL (Simulation-Driven Differentiable Active Learning) framework was pushed into this repository. The following instructures are about how to run different functionalities in the initially committed SDDAL. After the continual researcher is familiar with the initially committed original SDDAL, she will proceed to develop an continual learning scheme inside the SDDAL framework based on the initially pushed SDDAL code base.

# Data and folder preparation

Before running any experiments, the following folder structure must be prepared.

1, Six design folders must be created to contain the intensity and phase in both png images and numpy array files generated by the simulation in SDDAL, the Zernike coefficients used by the simulation to generate the corresponding intensity and phase, the uncertainty maps produced by the Quantile UNet-T model in the SDDAL, and the trained network weights of the Quantile UNet-T model everytime it is retrained on the accumulated training set:
- `Design_rec`
- `Design_ring`
- `Design_chair`
- `Design_gaussian`
- `Design_hat`
- `Design_tear`

Each design folder must share the same internal structure, shown below:

```text
Design_rec/
├── latest_uncertainty/
├── models/
├── training_set/
│   ├── intensity/
│   │   ├── img/
│   │   └── npy/
│   └── phase/
│   │   ├── img/
│   │   └── npy/
│   │── zernikes/
│
└── test_set/
    ├── intensity/
    │   ├── img/
    │   └── npy/
    └── phase/
    │   ├── img/
    │   └── npy/
    │
    │── zernikes/
```

2, For each beam shape, the corresponding test set must be copy-pasted from the original [Processed InShaPe dataset](https://doi.org/10.6084/m9.figshare.30131893.v4) to the test_set subfolder of the corresponding design folder above.

3, To this point, you can already run the SDDAL framework to generate data into the design folder. When you have generated enough data, you will need to officially train an UNet-T model or Quantile UNet-T model on the design-finished training dataset, then test the trained model on the InShaPe test set. To store inference results on test set, another six result folders must be created:
- `rec_result`
- `ring_result`
- `chair_result`
- `gaussian_result`
- `hat_result`
- `tear_result`

Each result folder must share the same internal structure, shown below:

```text
rec_result/
├── Phi_pred/
│   ├── img/
│   └── npy/
├── Phi_gt/
│   ├── img/
│   └── npy/
└── I_gt/
    ├── img/
    └── npy/
```

# Running SDDAL framework for dataset design

- 1, Quick experiment:

   - (1) Create 1000 initial samples by randomly sampling Zernike coefficients from uniform(-1.5, 1.5).
   
   - (2) Train a Quantile UNet model on the 1000 initial samples.

   - (3) SDDAL uses the PBF/LB-M beam shaping simulation and trained Quantile UNet-T for uncertainty sampling to generate 1000 active learned samples.

   - (4) The 1000 initial samples + 1000 active learned samples is the final 2000-sample training set.

   - (5) Train a randomly initialized UNet-T model on the final 2000-sample training set (GPU data) then test on the InShaPe test set (CPU data).
